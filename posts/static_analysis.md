---
title: Static Analysis
description: notes
date: 2023-05-01
tags:
  - static analysis
  - program analysis
---

## Motivation

- Fundamental knowledge in language, compiler and runtime implementation will help make better engineering decisions, everywhere.
- Compiler optimization trains in bit-fiddling as well as algorithmic thinking

## Approaches to Program Analysis

- Automated analysis of program behaviour, to find errors, optimize performance, find security vulnerabilities.
  - Data Flow Analysis.
  - Constraint Based Analysis.
  - Abstract Interpretation.
  - Type and Effect Systems.

## Introduction

- Compilers have two ways to understand programs
  - Static Analysis
  - Dynamic Analysis
- Static Analysistry to discover information about a program without running it.
- Dynamic Analysis runs the program and collect information about events that took place at runtime.

- Dynamic Analysis include
  - Profiling - execute and log events that happened at runtime. gprof
  - Test generation - produce tests that cover most of the program code. klee
  - Emulation - execute program in a virtual machine that takes care of collecting and analyzing data. valgrind
  - Instrumentation - augment the program with a meta-program that monitors its behviour. addressSanitizer.

- Static Analyses
  - Dataflow analyses
    - propagate information based on the dependencies between program elements, which are given by the syntax of the program.
  - Constraint-based analyses
    - we derive constraints from the program.Relations between these constraints are not determined explicitly by the program syntax
  - Type Analyses
    - propagate information as type annotations, allowing us to prove properties about the program such as progress and preservation. 

- Operational Semantics
  - *
  

## Data Flow Analysis

- Propagate analysis iformation along the edges of a control flow graph.
- Goal
  - Compute analysis state at each program point
- For each statement, define how it affects the analysis state.
- Availabel expression analysis
  - for each program point, compute which expressions must have already been computed and not later modified.
    - useful to avoid re-computing an expression
    - used as part of compiler optimizations
- Transfer Functions
  - How a given statement affects the analysis state
  - analysis state = available expressions
- Two functions
  - gen: availabe expressions generated by a statement
    - gen: Stmt -> P(Expr)
    - a statement generates an available expression e if;
      - it evaluated e
      - it does not later write any variable used in e.
    - otherwise function returns empty set.
  - kill: availabel expressions killed by a statement.
    - a statemtn kills an availabel expression e if;
      - it modifies any of the variable used in e
    - otherwise, returns an empty set.
- Always start with a control flow graph of a program beofre dataflow analysis.
- Propagating Available Expressions
  - Forward Analysis
    - propagate available expressions in the direction of control flow
    - for each statement s, outgoing available expressions are: incoming avail. exprs. minus kill(s) plus gen(s)
    - when control flow splits, propagate available expressions both ways
    - when control flows merge, intersect the incoming available expressions.
- Data Flow equations
  - AE(entry)(s), AE(exit)(s)

### Define a Data Flow Analysis

- Defined by 6 properties
  - Domain
    - analysis associated some information with every program input
      - infomration means elements of a set
    - Domain of analysis: all possible elements the set may have.
      - for all availabe expressions analysis: domain is set of non-trivial expressions
  - Direction
    - analysis propages information along the control flow graph
      - forward analysis: normal flow of control
      - backward analysis: invert all edges(reasons about executions in reverse)
  - Transfer Function
    - defines how a statement affects the propagated information.
    - dfexit(s) = some finctions of dfentry(s()
  - Meet Operator
    - what if two statements s1,s2 flow to a statement s?
      - forward analysis: execution branches merge
      - backward analysis: branching point
    - meet operator defined how to combine the incoming information
      - union
      - intersection
  - Boundary Condition
    - what information to start with at the first CFG node?
      - forward analysis: first node is the entry node.
      - backward analysis: first node is exit node
    - common choices
      - empty set
      - empty domain
  - Initial values
    - what is the information to start with at intermediate nodes?
    - common choices
      - empty set
      - empty domain
      
### Reaching Definitions Analysis

- For each program point compute which assignments may have been made and may not have been overwritten.
- Define the 6 properties of this analysis
  - domain - definitions in the code
  - direction - forward
  - meet operator - union
  - transfer function; gen(s), kill(s)
  - boundary condition - entry node starts with all varibles undefined
- always start with CFG.

### Very Busy expression analysis

- For each program point, find expressions that must be very busy, on all future paths, expressions will be used before any of the variables in it are redefined.
- useful for program optimizations, hoisting
- hoisting an expression, pre-compute it. before entering a block for later use.  
- define all 6 properties of the analysis
  - domain: all non-trivial expressions in code
  - direction: backward
  - meet: intersection
  - transfer function: backwards analysis - returns expressions that are very busy expressions at entry of statement.
  - boundary conditions: final node starts with no very busy expressions
  - initial values: no very busy expressions

### Live Variable Analysis

- For each statement, find variables that are may be live at the exit from the statement
- "live" - variable is used before being redefined.
- useful for identifying dead code
  - bug detections: dead assignments are typically unexpected
  - optimizations: remove dead code.
- define all 6 properties of the analysis
  - domain: all varibales occuring in the code
  - direction: backward
  - meet operator: union
  - transfer function: backward - returns set of variables that are live at entry of statement
  - boundary conditions: final node starts with no live variables.
  - initial values: all nodes have no libe variables

### Solving Data flow equations

- Transfer functions yield data flow equations for each statement.
- Round-robin, iterative algorithm
- Work List Algorithm
  - will it always terminate?
  - impose constraints to ensure terminations
    - domain of analysis
    - transfer function and meet operator are monotonic wrt to partial order.

### Intra vs Inter-procedural

- Intra
  - reason about a function in isolation
- Inter-
  - reason about multiple functions
  - calls and returns
  - one cfg per fucntion
  - connect call sites to entry nodes of callee
  - conect exit code back to call site.
  - analysis considers only possible inter-proc flows
  - arguments passed into call
  - return values propagated to caller
  - local variables not propagated, instead continues with state just before call.

### Sensitivities

- What your program looksat during analysis
  - Flow-sensitive: 
    - Takes into account the order of statements.
  - Path-sensitive: 
    - Takes into account the predicates at conditional brancehs
  - Context-sensitive(intra-procedural): 
    - Takes into account the specific call site that leads into another function.

## Call Graph Analysis

- Abstraction of all method calls in a program
  - Nodes: Methods
  - Edges: Calls
  - Flow-insensitive: No execution order

- Here: Static call graph
  - abstract of all calls that may execute  
  - gives an overestimation of calls

